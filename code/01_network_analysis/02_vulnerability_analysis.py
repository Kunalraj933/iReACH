import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import seaborn as sns

def simulate_node_removal(G, node_to_remove):
    """
    Simulate removal of a hospital and measure impact
    Returns metrics about network disruption
    """
    G_disrupted = G.copy()
    G_disrupted.remove_node(node_to_remove)
    
    # Calculate impact metrics
    impact = {
        'removed_node': node_to_remove,
        'original_nodes': G.number_of_nodes(),
        'remaining_nodes': G_disrupted.number_of_nodes(),
        'original_edges': G.number_of_edges(),
        'remaining_edges': G_disrupted.number_of_edges(),
        'edges_lost': G.number_of_edges() - G_disrupted.number_of_edges(),
        'original_components': nx.number_weakly_connected_components(G),
        'new_components': nx.number_weakly_connected_components(G_disrupted),
    }
    
    # Calculate affected patient volume
    # Sum of all edges connected to removed node
    affected_inflow = sum(
        G[u][node_to_remove]['weight'] 
        for u in G.predecessors(node_to_remove)
    )
    affected_outflow = sum(
        G[node_to_remove][v]['weight'] 
        for v in G.successors(node_to_remove)
    )
    
    impact['affected_patient_inflow'] = affected_inflow
    impact['affected_patient_outflow'] = affected_outflow
    impact['total_affected_patients'] = affected_inflow + affected_outflow
    
    # Calculate change in average path length
    if nx.is_weakly_connected(G) and nx.is_weakly_connected(G_disrupted):
        impact['original_avg_path_length'] = nx.average_shortest_path_length(
            G.to_undirected()
        )
        impact['new_avg_path_length'] = nx.average_shortest_path_length(
            G_disrupted.to_undirected()
        )
        impact['path_length_increase_pct'] = (
            (impact['new_avg_path_length'] - impact['original_avg_path_length']) /
            impact['original_avg_path_length'] * 100
        )
    else:
        impact['network_disconnected'] = True
    
    return impact, G_disrupted

def vulnerability_ranking(G, hospitals_to_test=None):
    """
    Test removal of multiple hospitals and rank by impact
    """
    if hospitals_to_test is None:
        hospitals_to_test = list(G.nodes())
    
    results = []
    for hospital in hospitals_to_test:
        impact, _ = simulate_node_removal(G, hospital)
        results.append(impact)
    
    results_df = pd.DataFrame(results)
    
    # Create vulnerability score (composite)
    results_df['vulnerability_score'] = (
        results_df['edges_lost'] * 0.3 +
        results_df['total_affected_patients'] * 0.4 +
        results_df.get('path_length_increase_pct', 0) * 0.3
    )
    
    results_df = results_df.sort_values(
        'vulnerability_score', 
        ascending=False
    )
    
    return results_df

